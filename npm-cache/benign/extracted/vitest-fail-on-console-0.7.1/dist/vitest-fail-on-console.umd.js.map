{"version":3,"file":"vitest-fail-on-console.umd.js","sources":["../src/types.ts","../src/index.ts"],"sourcesContent":["type SkipTestFunction = ({\n    testName,\n    testPath,\n}: {\n    testName?: string;\n    testPath?: string;\n}) => boolean;\n\ntype ErrorMessageFunction = (methodName: ConsoleMethod) => string;\n\ntype SilenceMessageFunction = (\n    message: string,\n    methodName: ConsoleMethod\n) => boolean;\n\nexport enum ConsoleMethod {\n    Assert = 'assert',\n    Debug = 'debug',\n    Error = 'error',\n    Info = 'info',\n    Log = 'log',\n    Warn = 'warn',\n}\n\nexport type ConsoleCallStacks = [string, string][];\n\nexport type VitestFailOnConsoleFunction = {\n    shouldFailOnAssert?: boolean;\n    shouldFailOnDebug?: boolean;\n    shouldFailOnError?: boolean;\n    shouldFailOnInfo?: boolean;\n    shouldFailOnLog?: boolean;\n    shouldFailOnWarn?: boolean;\n    skipTest?: SkipTestFunction;\n    errorMessage?: ErrorMessageFunction;\n    silenceMessage?: SilenceMessageFunction;\n    afterEachDelay?: number;\n};\n","import { beforeEach, afterEach, expect } from \"vitest\";\nimport * as util from 'util';\nimport chalk from 'chalk';\nimport {\n    ConsoleCallStacks,\n    ConsoleMethod,\n    VitestFailOnConsoleFunction,\n} from './types';\n\nconst LINE_RETURN = '\\n';\nconst defaultErrorMessage = (methodName: ConsoleMethod) =>\n    `vitest-fail-on-console > Expected test not to call ${chalk.bold(\n        `console.${methodName}()`\n    )}.\n    If the ${methodName} is expected, test for it explicitly by mocking it out using: \n    ${chalk.bold(\n        `vi.spyOn(console, '${methodName}').mockImplementation(() => {}) `\n    )}\n    and test that the warning occurs.`;\n\nconst init = (\n    {\n        errorMessage = defaultErrorMessage,\n        shouldFailOnAssert = false,\n        shouldFailOnDebug = false,\n        shouldFailOnError = true,\n        shouldFailOnInfo = false,\n        shouldFailOnLog = false,\n        shouldFailOnWarn = true,\n        skipTest = undefined,\n        silenceMessage = undefined,\n        afterEachDelay = undefined\n    }: VitestFailOnConsoleFunction = {\n        errorMessage: defaultErrorMessage,\n        shouldFailOnAssert: false,\n        shouldFailOnDebug: false,\n        shouldFailOnError: true,\n        shouldFailOnInfo: false,\n        shouldFailOnLog: false,\n        shouldFailOnWarn: true,\n        silenceMessage: undefined,\n        skipTest: undefined,\n        afterEachDelay: undefined\n    }\n) => {\n    const flushUnexpectedConsoleCalls = (\n        methodName: ConsoleMethod,\n        unexpectedConsoleCallStacks: ConsoleCallStacks\n    ) => {\n        if (unexpectedConsoleCallStacks.length) {\n            const messages = unexpectedConsoleCallStacks.map(\n                ([stack, message]) => {\n                    const stackLines = stack.split(LINE_RETURN);\n                    return (\n                        `${chalk.red(message)}${LINE_RETURN}` +\n                        `${stackLines\n                            .map((line, index) => {\n                                if (index === stackLines.length - 1) {\n                                    return chalk.white(line);\n                                }\n                                return chalk.gray(line);\n                            })\n                            .join(LINE_RETURN)}`\n                    );\n                }\n            );\n\n            const message = errorMessage(methodName);\n            const doubleLineReturn = `${LINE_RETURN}${LINE_RETURN}`;\n            throw new Error(\n                `${message}${doubleLineReturn}${messages.join(\n                    doubleLineReturn\n                )}`\n            );\n        }\n    };\n\n    const patchConsoleMethod = (methodName: ConsoleMethod) => {\n        const unexpectedConsoleCallStacks: ConsoleCallStacks = [];\n\n        const captureMessage = (format: unknown, ...args) => {\n            const message = util.format(format, ...args);\n            if (silenceMessage && silenceMessage(message, methodName)) {\n                return;\n            }\n\n            // Capture the call stack now, so we can warn about it later.\n            // The call stack has helpful information for the test author.\n            // Don't throw yet though b'c it might be accidentally caught and suppressed.\n            const { stack } = new Error();\n            if (stack) {\n                unexpectedConsoleCallStacks.push([\n                    stack.slice(stack.indexOf(LINE_RETURN) + 1),\n                    message,\n                ]);\n            }\n        };\n\n        const newAssertMethod = (\n            assertion: boolean,\n            format: unknown,\n            ...args\n        ) => {\n            if (assertion) {\n                return;\n            }\n            captureMessage(format, ...args);\n        };\n\n        const newMethod =\n            methodName === ConsoleMethod.Assert\n                ? newAssertMethod\n                : captureMessage;\n\n        const originalMethod = console[methodName];\n\n        const isTestSkipped = (): boolean => {\n            const currentTestState = expect.getState();\n            const testName = currentTestState.currentTestName;\n            const testPath = currentTestState.testPath;\n            return !!skipTest?.({ testName, testPath });\n        };\n\n        beforeEach(() => {\n            if (isTestSkipped()) {\n                return;\n            }\n            console[methodName] = newMethod; // eslint-disable-line no-console\n            unexpectedConsoleCallStacks.length = 0;\n        });\n\n        afterEach(async () => {\n            if (isTestSkipped()) {\n                return;\n            }\n            if (afterEachDelay) {\n                await new Promise(resolve => setTimeout(resolve, afterEachDelay));\n            }\n            flushUnexpectedConsoleCalls(\n                methodName,\n                unexpectedConsoleCallStacks\n            );\n            console[methodName] = originalMethod;\n        });\n    };\n\n    [\n        [shouldFailOnAssert, ConsoleMethod.Assert],\n        [shouldFailOnDebug, ConsoleMethod.Debug],\n        [shouldFailOnError, ConsoleMethod.Error],\n        [shouldFailOnInfo, ConsoleMethod.Info],\n        [shouldFailOnLog, ConsoleMethod.Log],\n        [shouldFailOnWarn, ConsoleMethod.Warn],\n    ].forEach(([condition, methodName]: [boolean, ConsoleMethod]) => {\n        if (condition) {\n            patchConsoleMethod(methodName);\n        }\n    });\n};\n\nexport default init;\n"],"names":["ConsoleMethod","LINE_RETURN","defaultErrorMessage","methodName","chalk","init","errorMessage","shouldFailOnAssert","shouldFailOnDebug","shouldFailOnError","shouldFailOnInfo","shouldFailOnLog","shouldFailOnWarn","skipTest","silenceMessage","afterEachDelay","flushUnexpectedConsoleCalls","unexpectedConsoleCallStacks","messages","stack","message","stackLines","line","index","doubleLineReturn","patchConsoleMethod","captureMessage","format","args","util","newAssertMethod","assertion","newMethod","originalMethod","isTestSkipped","currentTestState","expect","testName","testPath","beforeEach","afterEach","resolve","condition"],"mappings":"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"}