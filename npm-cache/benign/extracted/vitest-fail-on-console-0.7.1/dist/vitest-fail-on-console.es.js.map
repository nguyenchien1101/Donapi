{"version":3,"file":"vitest-fail-on-console.es.js","sources":["../src/types.ts","../src/index.ts"],"sourcesContent":["type SkipTestFunction = ({\n    testName,\n    testPath,\n}: {\n    testName?: string;\n    testPath?: string;\n}) => boolean;\n\ntype ErrorMessageFunction = (methodName: ConsoleMethod) => string;\n\ntype SilenceMessageFunction = (\n    message: string,\n    methodName: ConsoleMethod\n) => boolean;\n\nexport enum ConsoleMethod {\n    Assert = 'assert',\n    Debug = 'debug',\n    Error = 'error',\n    Info = 'info',\n    Log = 'log',\n    Warn = 'warn',\n}\n\nexport type ConsoleCallStacks = [string, string][];\n\nexport type VitestFailOnConsoleFunction = {\n    shouldFailOnAssert?: boolean;\n    shouldFailOnDebug?: boolean;\n    shouldFailOnError?: boolean;\n    shouldFailOnInfo?: boolean;\n    shouldFailOnLog?: boolean;\n    shouldFailOnWarn?: boolean;\n    skipTest?: SkipTestFunction;\n    errorMessage?: ErrorMessageFunction;\n    silenceMessage?: SilenceMessageFunction;\n    afterEachDelay?: number;\n};\n","import { beforeEach, afterEach, expect } from \"vitest\";\nimport * as util from 'util';\nimport chalk from 'chalk';\nimport {\n    ConsoleCallStacks,\n    ConsoleMethod,\n    VitestFailOnConsoleFunction,\n} from './types';\n\nconst LINE_RETURN = '\\n';\nconst defaultErrorMessage = (methodName: ConsoleMethod) =>\n    `vitest-fail-on-console > Expected test not to call ${chalk.bold(\n        `console.${methodName}()`\n    )}.\n    If the ${methodName} is expected, test for it explicitly by mocking it out using: \n    ${chalk.bold(\n        `vi.spyOn(console, '${methodName}').mockImplementation(() => {}) `\n    )}\n    and test that the warning occurs.`;\n\nconst init = (\n    {\n        errorMessage = defaultErrorMessage,\n        shouldFailOnAssert = false,\n        shouldFailOnDebug = false,\n        shouldFailOnError = true,\n        shouldFailOnInfo = false,\n        shouldFailOnLog = false,\n        shouldFailOnWarn = true,\n        skipTest = undefined,\n        silenceMessage = undefined,\n        afterEachDelay = undefined\n    }: VitestFailOnConsoleFunction = {\n        errorMessage: defaultErrorMessage,\n        shouldFailOnAssert: false,\n        shouldFailOnDebug: false,\n        shouldFailOnError: true,\n        shouldFailOnInfo: false,\n        shouldFailOnLog: false,\n        shouldFailOnWarn: true,\n        silenceMessage: undefined,\n        skipTest: undefined,\n        afterEachDelay: undefined\n    }\n) => {\n    const flushUnexpectedConsoleCalls = (\n        methodName: ConsoleMethod,\n        unexpectedConsoleCallStacks: ConsoleCallStacks\n    ) => {\n        if (unexpectedConsoleCallStacks.length) {\n            const messages = unexpectedConsoleCallStacks.map(\n                ([stack, message]) => {\n                    const stackLines = stack.split(LINE_RETURN);\n                    return (\n                        `${chalk.red(message)}${LINE_RETURN}` +\n                        `${stackLines\n                            .map((line, index) => {\n                                if (index === stackLines.length - 1) {\n                                    return chalk.white(line);\n                                }\n                                return chalk.gray(line);\n                            })\n                            .join(LINE_RETURN)}`\n                    );\n                }\n            );\n\n            const message = errorMessage(methodName);\n            const doubleLineReturn = `${LINE_RETURN}${LINE_RETURN}`;\n            throw new Error(\n                `${message}${doubleLineReturn}${messages.join(\n                    doubleLineReturn\n                )}`\n            );\n        }\n    };\n\n    const patchConsoleMethod = (methodName: ConsoleMethod) => {\n        const unexpectedConsoleCallStacks: ConsoleCallStacks = [];\n\n        const captureMessage = (format: unknown, ...args) => {\n            const message = util.format(format, ...args);\n            if (silenceMessage && silenceMessage(message, methodName)) {\n                return;\n            }\n\n            // Capture the call stack now, so we can warn about it later.\n            // The call stack has helpful information for the test author.\n            // Don't throw yet though b'c it might be accidentally caught and suppressed.\n            const { stack } = new Error();\n            if (stack) {\n                unexpectedConsoleCallStacks.push([\n                    stack.slice(stack.indexOf(LINE_RETURN) + 1),\n                    message,\n                ]);\n            }\n        };\n\n        const newAssertMethod = (\n            assertion: boolean,\n            format: unknown,\n            ...args\n        ) => {\n            if (assertion) {\n                return;\n            }\n            captureMessage(format, ...args);\n        };\n\n        const newMethod =\n            methodName === ConsoleMethod.Assert\n                ? newAssertMethod\n                : captureMessage;\n\n        const originalMethod = console[methodName];\n\n        const isTestSkipped = (): boolean => {\n            const currentTestState = expect.getState();\n            const testName = currentTestState.currentTestName;\n            const testPath = currentTestState.testPath;\n            return !!skipTest?.({ testName, testPath });\n        };\n\n        beforeEach(() => {\n            if (isTestSkipped()) {\n                return;\n            }\n            console[methodName] = newMethod; // eslint-disable-line no-console\n            unexpectedConsoleCallStacks.length = 0;\n        });\n\n        afterEach(async () => {\n            if (isTestSkipped()) {\n                return;\n            }\n            if (afterEachDelay) {\n                await new Promise(resolve => setTimeout(resolve, afterEachDelay));\n            }\n            flushUnexpectedConsoleCalls(\n                methodName,\n                unexpectedConsoleCallStacks\n            );\n            console[methodName] = originalMethod;\n        });\n    };\n\n    [\n        [shouldFailOnAssert, ConsoleMethod.Assert],\n        [shouldFailOnDebug, ConsoleMethod.Debug],\n        [shouldFailOnError, ConsoleMethod.Error],\n        [shouldFailOnInfo, ConsoleMethod.Info],\n        [shouldFailOnLog, ConsoleMethod.Log],\n        [shouldFailOnWarn, ConsoleMethod.Warn],\n    ].forEach(([condition, methodName]: [boolean, ConsoleMethod]) => {\n        if (condition) {\n            patchConsoleMethod(methodName);\n        }\n    });\n};\n\nexport default init;\n"],"names":["ConsoleMethod","LINE_RETURN","defaultErrorMessage","methodName","chalk","init","errorMessage","shouldFailOnAssert","shouldFailOnDebug","shouldFailOnError","shouldFailOnInfo","shouldFailOnLog","shouldFailOnWarn","skipTest","silenceMessage","afterEachDelay","flushUnexpectedConsoleCalls","unexpectedConsoleCallStacks","messages","stack","message","stackLines","line","index","doubleLineReturn","patchConsoleMethod","captureMessage","format","args","util","newAssertMethod","assertion","newMethod","originalMethod","isTestSkipped","currentTestState","expect","testName","testPath","beforeEach","afterEach","resolve","condition"],"mappings":"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"}