/**
 * @name html-crush
 * @fileoverview Minify email templates
 * @version 6.0.22
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/html-crush/}
 */

"use strict";var htmlCrush=(()=>{var Me=Object.create;var G=Object.defineProperty;var Pe=Object.getOwnPropertyDescriptor;var He=Object.getOwnPropertyNames,ge=Object.getOwnPropertySymbols,Fe=Object.getPrototypeOf,me=Object.prototype.hasOwnProperty,_e=Object.prototype.propertyIsEnumerable;var Z=(e,r,l)=>r in e?G(e,r,{enumerable:!0,configurable:!0,writable:!0,value:l}):e[r]=l,w=(e,r)=>{for(var l in r||(r={}))me.call(r,l)&&Z(e,l,r[l]);if(ge)for(var l of ge(r))_e.call(r,l)&&Z(e,l,r[l]);return e};var xe=(e,r)=>()=>(r||e((r={exports:{}}).exports,r),r.exports),ke=(e,r)=>{for(var l in r)G(e,l,{get:r[l],enumerable:!0})},ce=(e,r,l,t)=>{if(r&&typeof r=="object"||typeof r=="function")for(let a of He(r))!me.call(e,a)&&a!==l&&G(e,a,{get:()=>r[a],enumerable:!(t=Pe(r,a))||t.enumerable});return e};var fe=(e,r,l)=>(l=e!=null?Me(Fe(e)):{},ce(r||!e||!e.__esModule?G(l,"default",{value:e,enumerable:!0}):l,e)),We=e=>ce(G({},"__esModule",{value:!0}),e);var ee=(e,r,l)=>Z(e,typeof r!="symbol"?r+"":r,l);var ne=xe(($t,be)=>{"use strict";be.exports=je;function W(e){return e instanceof Buffer?Buffer.from(e):new e.constructor(e.buffer.slice(),e.byteOffset,e.length)}function je(e){if(e=e||{},e.circles)return Ue(e);let r=new Map;if(r.set(Date,u=>new Date(u)),r.set(Map,(u,s)=>new Map(t(Array.from(u),s))),r.set(Set,(u,s)=>new Set(t(Array.from(u),s))),e.constructorHandlers)for(let u of e.constructorHandlers)r.set(u[0],u[1]);let l=null;return e.proto?i:a;function t(u,s){let g=Object.keys(u),o=new Array(g.length);for(let m=0;m<g.length;m++){let c=g[m],y=u[c];typeof y!="object"||y===null?o[c]=y:y.constructor!==Object&&(l=r.get(y.constructor))?o[c]=l(y,s):ArrayBuffer.isView(y)?o[c]=W(y):o[c]=s(y)}return o}function a(u){if(typeof u!="object"||u===null)return u;if(Array.isArray(u))return t(u,a);if(u.constructor!==Object&&(l=r.get(u.constructor)))return l(u,a);let s={};for(let g in u){if(Object.hasOwnProperty.call(u,g)===!1)continue;let o=u[g];typeof o!="object"||o===null?s[g]=o:o.constructor!==Object&&(l=r.get(o.constructor))?s[g]=l(o,a):ArrayBuffer.isView(o)?s[g]=W(o):s[g]=a(o)}return s}function i(u){if(typeof u!="object"||u===null)return u;if(Array.isArray(u))return t(u,i);if(u.constructor!==Object&&(l=r.get(u.constructor)))return l(u,i);let s={};for(let g in u){let o=u[g];typeof o!="object"||o===null?s[g]=o:o.constructor!==Object&&(l=r.get(o.constructor))?s[g]=l(o,i):ArrayBuffer.isView(o)?s[g]=W(o):s[g]=i(o)}return s}}function Ue(e){let r=[],l=[],t=new Map;if(t.set(Date,g=>new Date(g)),t.set(Map,(g,o)=>new Map(i(Array.from(g),o))),t.set(Set,(g,o)=>new Set(i(Array.from(g),o))),e.constructorHandlers)for(let g of e.constructorHandlers)t.set(g[0],g[1]);let a=null;return e.proto?s:u;function i(g,o){let m=Object.keys(g),c=new Array(m.length);for(let y=0;y<m.length;y++){let $=m[y],h=g[$];if(typeof h!="object"||h===null)c[$]=h;else if(h.constructor!==Object&&(a=t.get(h.constructor)))c[$]=a(h,o);else if(ArrayBuffer.isView(h))c[$]=W(h);else{let O=r.indexOf(h);O!==-1?c[$]=l[O]:c[$]=o(h)}}return c}function u(g){if(typeof g!="object"||g===null)return g;if(Array.isArray(g))return i(g,u);if(g.constructor!==Object&&(a=t.get(g.constructor)))return a(g,u);let o={};r.push(g),l.push(o);for(let m in g){if(Object.hasOwnProperty.call(g,m)===!1)continue;let c=g[m];if(typeof c!="object"||c===null)o[m]=c;else if(c.constructor!==Object&&(a=t.get(c.constructor)))o[m]=a(c,u);else if(ArrayBuffer.isView(c))o[m]=W(c);else{let y=r.indexOf(c);y!==-1?o[m]=l[y]:o[m]=u(c)}}return r.pop(),l.pop(),o}function s(g){if(typeof g!="object"||g===null)return g;if(Array.isArray(g))return i(g,s);if(g.constructor!==Object&&(a=t.get(g.constructor)))return a(g,s);let o={};r.push(g),l.push(o);for(let m in g){let c=g[m];if(typeof c!="object"||c===null)o[m]=c;else if(c.constructor!==Object&&(a=t.get(c.constructor)))o[m]=a(c,s);else if(ArrayBuffer.isView(c))o[m]=W(c);else{let y=r.indexOf(c);y!==-1?o[m]=l[y]:o[m]=s(c)}}return r.pop(),l.pop(),o}}});var nt={};ke(nt,{crush:()=>tt,defaults:()=>Ie,version:()=>et});var Je={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function k(e,r){if(!Array.isArray(e)||!e.length)return e;let l=w(w({},Je),r),t,a;if(l.strictlyTwoElementsInRangeArrays&&!e.every((s,g)=>!Array.isArray(s)||s.length!==2?(t=g,a=s.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${t}th range (${JSON.stringify(e[t],null,4)}) has not two but ${a} elements!`);if(!e.every((s,g)=>!Array.isArray(s)||!Number.isInteger(s[0])||s[0]<0||!Number.isInteger(s[1])||s[1]<0?(t=g,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${t}th range (${JSON.stringify(e[t],null,4)}) does not consist of only natural numbers!`);let i=e.length**2,u=0;return Array.from(e).sort((s,g)=>(l.progressFn&&(u+=1,l.progressFn(Math.floor(u*100/i))),s[0]===g[0]?s[1]<g[1]?-1:s[1]>g[1]?1:0:s[0]<g[0]?-1:1))}var $e={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function he(e,r){function l(o){return!!o&&typeof o=="object"&&!Array.isArray(o)}if(!Array.isArray(e)||!e.length)return null;let t;if(r)if(l(r)){if(t=w(w({},$e),r),t.progressFn&&l(t.progressFn)&&!Object.keys(t.progressFn).length)t.progressFn=null;else if(t.progressFn&&typeof t.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof t.progressFn}", equal to ${JSON.stringify(t.progressFn,null,4)}`);if(![1,2,"1","2"].includes(t.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof t.mergeType}", equal to ${JSON.stringify(t.mergeType,null,4)}`);if(typeof t.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof t.joinRangesThatTouchEdges}", equal to ${JSON.stringify(t.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(r,null,4)} (type ${typeof r})`);else t=w({},$e);let a=e.filter(o=>Array.isArray(o)).map(o=>[...o]).filter(o=>o[2]!==void 0||o[0]!==o[1]),i,u,s;t.progressFn?i=k(a,{progressFn:o=>{s=Math.floor(o/5),s!==u&&(u=s,t.progressFn(s))}}):i=k(a);let g=i.length-1;for(let o=g;o>0;o--)t.progressFn&&(s=Math.floor((1-o/g)*78)+21,s!==u&&s>u&&(u=s,t.progressFn(s))),(i[o][0]<=i[o-1][0]||!t.joinRangesThatTouchEdges&&i[o][0]<i[o-1][1]||t.joinRangesThatTouchEdges&&i[o][0]<=i[o-1][1])&&(i[o-1][0]=Math.min(i[o][0],i[o-1][0]),i[o-1][1]=Math.max(i[o][1],i[o-1][1]),i[o][2]!==void 0&&(i[o-1][0]>=i[o][0]||i[o-1][1]<=i[o][1])&&i[o-1][2]!==null&&(i[o][2]===null&&i[o-1][2]!==null?i[o-1][2]=null:i[o-1][2]!=null?+t.mergeType==2&&i[o-1][0]===i[o][0]?i[o-1][2]=i[o][2]:i[o-1][2]+=i[o][2]:i[o-1][2]=i[o][2]),i.splice(o,1),o=i.length);return i.length?i:null}var Be=!0,te="Invariant failed";function pe(e,r){if(!e){if(Be)throw new Error(te);var l=typeof r=="function"?r():r,t=l?"".concat(te,": ").concat(l):te;throw new Error(t)}}function de(e,r,l){let t=0,a=0;if(arguments.length===0)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(typeof e!="string")throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(r&&!Array.isArray(r))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof r}, equal to: ${JSON.stringify(r,null,4)}`);if(l&&typeof l!="function")throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof l}, equal to: ${JSON.stringify(l,null,4)}`);if(!(r!=null&&r.filter(m=>m).length))return e;let i;Array.isArray(r)&&Number.isInteger(r[0])&&Number.isInteger(r[1])?i=[Array.from(r)]:i=Array.from(r);let u=i.length,s=0;i.filter(m=>m).forEach((m,c)=>{if(l&&(t=Math.floor(s/u*10),t!==a&&(a=t,l(t))),!Array.isArray(m))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${c}th element not an array: ${JSON.stringify(m,null,4)}, which is ${typeof m}`);if(!Number.isInteger(m[0])){if(!Number.isInteger(+m[0])||+m[0]<0)throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${c}th element, array ${JSON.stringify(m,null,0)}. Its first element is not an integer, string index, but ${typeof m[0]}, equal to: ${JSON.stringify(m[0],null,4)}.`);i[c][0]=+i[c][0]}if(!Number.isInteger(m[1])){if(!Number.isInteger(+m[1])||+m[1]<0)throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${c}th element, array ${JSON.stringify(m,null,0)}. Its second element is not an integer, string index, but ${typeof m[1]}, equal to: ${JSON.stringify(m[1],null,4)}.`);i[c][1]=+i[c][1]}s+=1});let g=he(i,{progressFn:m=>{l&&(t=10+Math.floor(m/10),t!==a&&(a=t,l(t)))}});pe(g);let o=g.length;if(o>0){let m=e.slice(g[o-1][1]);e=g.reduce((c,y,$,h)=>{l&&(t=20+Math.floor($/o*80),t!==a&&(a=t,l(t)));let O=$===0?0:h[$-1][1],C=h[$][0];return`${c}${e.slice(O,C)}${h[$][2]||""}`},""),e+=m}return e}function Y(e,r=1){let l="\xA0";function t(i){return Array.from(i).reverse().join("")}function a(i,u,s){let g=s?`
`:"\r",o=s?"\r":`
`;if(!i)return i;let m=0,c=0,y="";for(let $=0,h=i.length;$<h;$++)(i[$]===g||i[$]===o&&i[$-1]!==g)&&c++,`\r
`.includes(i[$])||i[$]===l?(m=0,i[$]===l?y+=i[$]:i[$]===g?c<=u&&(y+=i[$],i[$+1]===o&&(y+=i[$+1],$++)):i[$]===o&&(i==null?void 0:i[$-1])!==g&&c<=u&&(y+=i[$])):(m++,!i[$+1]&&!c&&(y+=" "));return y}if(typeof e=="string"&&e.length){let i=1;typeof+r=="number"&&Number.isInteger(+r)&&+r>=0&&(i=+r);let u="",s="";if(!e.trim())u=e;else if(!e[0].trim()){for(let g=0,o=e.length;g<o;g++)if(e[g].trim()){u=e.slice(0,g);break}}if(e.trim()&&(e.slice(-1).trim()===""||e.slice(-1)===l)){for(let g=e.length;g--;)if(e[g].trim()){s=e.slice(g+1);break}}return`${a(u,i,!1)}${e.trim()}${t(a(t(s),i,!0))}`}return e}var Te=fe(ne(),1);var ht=(0,Te.default)();function F(e){return S(e)&&e.length===1&&e.toUpperCase()!==e.toLowerCase()}function M(e){if(e==null||typeof e!="object")return!1;let r=Object.getPrototypeOf(e);return r!==null&&r!==Object.prototype&&Object.getPrototypeOf(r)!==null?!1:!(Symbol.iterator in e)&&!(Symbol.toStringTag in e)}function S(e){return typeof e=="string"}function v(e){return Number.isSafeInteger(e)&&e>=0}function P(e){return e!=null}function ye(e,r){return M(e)&&S(r)&&r in e}var Ee={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function Ge(e,r){var o;function l(m){return!!m&&typeof m=="object"&&!Array.isArray(m)}if(!Array.isArray(e)||!e.length)return null;let t;if(r)if(l(r)){if(t=w(w({},Ee),r),t.progressFn&&l(t.progressFn)&&!Object.keys(t.progressFn).length)t.progressFn=null;else if(t.progressFn&&typeof t.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] resolvedOpts.progressFn must be a function! It was given of a type: "${typeof t.progressFn}", equal to ${JSON.stringify(t.progressFn,null,4)}`);if(![1,2,"1","2"].includes(t.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] resolvedOpts.mergeType was customised to a wrong thing! It was given of a type: "${typeof t.mergeType}", equal to ${JSON.stringify(t.mergeType,null,4)}`);if(typeof t.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] resolvedOpts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof t.joinRangesThatTouchEdges}", equal to ${JSON.stringify(t.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`ranges-merge: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(r,null,4)} (type ${typeof r})`);else t=w({},Ee);let a=e.filter(m=>Array.isArray(m)).map(m=>[...m]).filter(m=>m[2]!==void 0||m[0]!==m[1]),i,u,s;t.progressFn?i=k(a,{progressFn:m=>{s=Math.floor(m/5),s!==u&&(u=s,t.progressFn!=null&&t.progressFn(s))}}):i=k(a);let g=i.length-1;for(let m=g;m>0;m--)t.progressFn&&(s=Math.floor((1-m/g)*78)+21,s!==u&&s>u&&(u=s,t.progressFn(s))),(i[m][0]<=i[m-1][0]||!t.joinRangesThatTouchEdges&&i[m][0]<i[m-1][1]||t.joinRangesThatTouchEdges&&i[m][0]<=i[m-1][1])&&(i[m-1][0]=Math.min(i[m][0],i[m-1][0]),i[m-1][1]=Math.max(i[m][1],i[m-1][1]),i[m][2]!==void 0&&(i[m-1][0]>=i[m][0]||i[m-1][1]<=i[m][1])&&i[m-1][2]!==null&&(i[m][2]===null&&i[m-1][2]!==null?i[m-1][2]=null:i[m-1][2]!=null?+((o=t||{})==null?void 0:o.mergeType)==2&&i[m-1][0]===i[m][0]?i[m-1][2]=i[m][2]:i[m-1][2]+=i[m][2]:i[m-1][2]=i[m][2]),i.splice(m,1),m=i.length);return i.length?i:null}var qe={limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1},Se=class{constructor(e){ee(this,"ranges");ee(this,"opts");let r=w(w({},qe),e);if(r.mergeType&&r.mergeType!==1&&r.mergeType!==2)if(S(r.mergeType)&&r.mergeType.trim()==="1")r.mergeType=1;else if(S(r.mergeType)&&r.mergeType.trim()==="2")r.mergeType=2;else throw new Error(`ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof r.mergeType}", equal to ${JSON.stringify(r.mergeType,null,4)}`);this.opts=r,this.ranges=[]}add(e,r,l){var i;if(e==null&&r==null)return;if(P(e)&&!P(r)){if(Array.isArray(e)){if(e.length){if(e.some(u=>Array.isArray(u))){e.forEach(u=>{Array.isArray(u)&&this.add(...u)});return}e.length&&v(+e[0])&&v(+e[1])&&this.add(...e)}return}throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set (${JSON.stringify(e,null,0)}) but second-one, "to" is not (${JSON.stringify(r,null,0)})`)}else if(!P(e)&&P(r))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set (${JSON.stringify(r,null,0)}) but first-one, "from" is not (${JSON.stringify(e,null,0)})`);let t=+e,a=+r;if(v(l)&&(l=String(l)),v(t)&&v(a)){if(P(l)&&!S(l)&&!v(l))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ${typeof l}, equal to:
${JSON.stringify(l,null,4)}`);if(P(this.ranges)&&Array.isArray(this.last())&&t===this.last()[1]){if(this.last()[1]=a,this.last()[2],this.last()[2]!==null&&P(l)){let u=this.last()[2]&&this.last()[2].length&&(!((i=this.opts)!=null&&i.mergeType)||this.opts.mergeType===1)?`${this.last()[2]}${l}`:l;this.opts.limitToBeAddedWhitespace&&(u=Y(u,this.opts.limitLinebreaksCount)),S(u)&&!u.length||(this.last()[2]=u)}}else{this.ranges||(this.ranges=[]);let u=l!==void 0&&!(S(l)&&!l.length)?[t,a,l&&this.opts.limitToBeAddedWhitespace?Y(l,this.opts.limitLinebreaksCount):l]:[t,a];this.ranges.push(u)}}else throw v(t)&&t>=0?new TypeError(`ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it's of a type "${typeof a}" equal to: ${JSON.stringify(a,null,4)}`):new TypeError(`ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it's of a type "${typeof t}" equal to: ${JSON.stringify(t,null,4)}`)}push(e,r,l){this.add(e,r,l)}current(){return Array.isArray(this.ranges)&&this.ranges.length?(this.ranges=Ge(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map(e=>P(e[2])?[e[0],e[1],Y(e[2],this.opts.limitLinebreaksCount)]:e):this.ranges):null}wipe(){this.ranges=[]}replace(e){if(Array.isArray(e)&&e.length)if(Array.isArray(e[0])&&v(e[0][0]))this.ranges=Array.from(e);else throw new Error(`ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ${JSON.stringify(e[0],null,4)} should be an array and its first element should be an integer, a string index.`);else this.ranges=[]}last(){return Array.isArray(this.ranges)&&this.ranges.length?this.ranges[this.ranges.length-1]:null}};function Oe(e){return typeof e!="string"?e:e.length?[e]:[]}var we={cb:void 0,i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1,hungry:!1},Ye=e=>e+1;function Ke(e,r,l,t,a=!1,i=Ye){var b;let u=typeof l=="function"?l():l;if(+r<0&&a&&u==="EOL")return u;let s=w(w({},we),t);if(r>=e.length&&!a)return!1;let g=a?1:l.length,o=0,m=!1,c=!1,y=!1,$=s.maxMismatches,h=r,O=!1,C=!1,T=!1;function p(){return o===1&&$<s.maxMismatches-1}for(;e[h];){let d=i(h);if(s.trimBeforeMatching&&e[h].trim()===""){if(!e[d]&&a&&l==="EOL")return!0;h=i(h);continue}if(s&&!s.i&&((b=s==null?void 0:s.trimCharsBeforeMatching)!=null&&b.includes(e[h]))||s!=null&&s.i&&s.trimCharsBeforeMatching&&s.trimCharsBeforeMatching.map(N=>N.toLowerCase()).includes(e[h].toLowerCase())){if(a&&l==="EOL"&&!e[d])return!0;h=i(h);continue}let D=d>h?l[l.length-g]:l[g-1];if(!s.i&&e[h]===D||s.i&&e[h].toLowerCase()===D.toLowerCase()){if(O||(O=!0),y||(y=!0),g===l.length){if(C=!0,$!==s.maxMismatches)return!1}else g===1&&(T=!0);if(g-=1,o++,p())return!1;if(!g)return o!==l.length||$===s.maxMismatches||!m?h:!1}else if(!m&&!o&&(m=!0),s.maxMismatches&&$&&h){$-=1;for(let N=0;N<=$;N++){let R=d>h?l[l.length-g+1+N]:l[g-2-N],V=e[i(h)];if(R&&(!s.i&&e[h]===R||s.i&&e[h].toLowerCase()===R.toLowerCase())&&(!s.firstMustMatch||g!==l.length)){if(o++,p())return!1;g-=2,O=!0;break}else if(V&&R&&(!s.i&&V===R||s.i&&V.toLowerCase()===R.toLowerCase())&&(!s.firstMustMatch||g!==l.length)){if(!o&&!s.hungry)return!1;g-=1,O=!0;break}else if(R===void 0&&$>=0&&O&&(!s.firstMustMatch||C)&&(!s.lastMustMatch||T))return h}O||(c=h)}else return h===0&&g===1&&!s.lastMustMatch&&y?0:!1;if(c!==!1&&c!==h&&(c=!1),g<1)return h;h=i(h)}if(g>0)return a&&u==="EOL"?!0:s&&s.maxMismatches>=g&&y?c||0:!1}function re(e,r,l,t,a){var m,c,y;if(M(a)&&ye(a,"trimBeforeMatching")&&a&&typeof a.trimBeforeMatching!="boolean")throw new Error(`string-match-left-right/${e}(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!${Array.isArray(a.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""}`);let i=w(w({},we),a);if(typeof i.trimCharsBeforeMatching=="string"&&(i.trimCharsBeforeMatching=Oe(i.trimCharsBeforeMatching)),i.trimCharsBeforeMatching=i.trimCharsBeforeMatching.map($=>S($)?$:String($)),!S(r)||!r.length)return!1;if(!Number.isInteger(l)||l<0)throw new Error(`string-match-left-right/${e}(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ${typeof l}, equal to:
${JSON.stringify(l,null,4)}`);let u,s;if(S(t))u=[t];else if(Array.isArray(t))u=t;else if(!t)u=t;else if(typeof t=="function")u=[],u.push(t);else throw new Error(`string-match-left-right/${e}(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ${typeof t}, equal to:
${JSON.stringify(t,null,4)}`);if(a&&!M(a))throw new Error(`string-match-left-right/${e}(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type "${typeof a}", and equal to:
${JSON.stringify(a,null,4)}`);let g=0,o="";if((m=i==null?void 0:i.trimCharsBeforeMatching)!=null&&m.some(($,h)=>$.length>1?(g=h,o=$,!0):!1))throw new Error(`string-match-left-right/${e}(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ${g} is longer than 1 character, ${o.length} (equals to ${o}). Please split it into separate characters and put into array as separate elements.`);if(!u||!Array.isArray(u)||Array.isArray(u)&&!u.length||Array.isArray(u)&&u.length===1&&S(u[0])&&!u[0].trim()){if(typeof i.cb=="function"){let h,O=l;if((e==="matchLeftIncl"||e==="matchRight")&&(O+=1),e[5]==="L")for(let b=O;b--;){let d=r[b];if((!i.trimBeforeMatching||i.trimBeforeMatching&&(d!=null&&d.trim()))&&(!((c=i.trimCharsBeforeMatching)!=null&&c.length)||d!==void 0&&!i.trimCharsBeforeMatching.includes(d))){h=b;break}}else if(e.startsWith("matchRight"))for(let b=O;b<r.length;b++){let d=r[b];if((!i.trimBeforeMatching||i.trimBeforeMatching&&d.trim())&&(!((y=i.trimCharsBeforeMatching)!=null&&y.length)||!i.trimCharsBeforeMatching.includes(d))){h=b;break}}if(h===void 0)return!1;let C=r[h],T=h+1,p="";return T&&T>0&&(p=r.slice(0,T)),e[5]==="L"||h&&h>0&&(p=r.slice(h)),i.cb(C,p,h)}let $="";throw a||($=" More so, the whole options object, the fourth input argument, is missing!"),new Error(`string-match-left-right/${e}(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!${$}`)}for(let $=0,h=u.length;$<h;$++){s=typeof u[$]=="function";let O=u[$],C,T,p="",b=l;e==="matchRight"?b+=1:e==="matchLeft"&&(b-=1);let d=Ke(r,b,O,i,s,D=>e[5]==="L"?D-1:D+1);if(d&&s&&typeof O=="function"&&O()==="EOL")return O()&&(!i.cb||i.cb(C,p,T))?O():!1;if(Number.isInteger(d)&&(T=e.startsWith("matchLeft")?d-1:d+1,e[5]==="L"?p=r.slice(0,d):p=r.slice(T)),T<0&&(T=void 0),r[T]&&(C=r[T]),Number.isInteger(d)&&(!i.cb||i.cb(C,p,T)))return O}return!1}function Le(e,r,l,t){return re("matchLeft",e,r,l,t)}function ie(e,r,l,t){return re("matchRightIncl",e,r,l,t)}function J(e,r,l,t){return re("matchRight",e,r,l,t)}var ze={str:"",from:0,to:0,ifLeftSideIncludesThisThenCropTightly:"",ifLeftSideIncludesThisCropItToo:"",ifRightSideIncludesThisThenCropTightly:"",ifRightSideIncludesThisCropItToo:"",extendToOneSide:!1,wipeAllWhitespaceOnLeft:!1,wipeAllWhitespaceOnRight:!1,addSingleSpaceToPreventAccidentalConcatenation:!1};function K(e){var s,g;let r=/^[0-9a-zA-Z]+$/;function l(o){return S(o)&&!o.trim()}if(M(e)){if(!Object.keys(e).length)throw new Error(`string-range-expander: [THROW_ID_02] Input must be a plain object but it's been given as a plain object without any keys. However, "from" and "to" settings are obligatory!`)}else{let o;throw e===void 0?o="but it is missing completely.":e===null?o="but it was given as null.":o=`but it was given as ${typeof e}, equal to:
${JSON.stringify(e,null,4)}.`,new Error(`string-range-expander: [THROW_ID_01] Input must be a plain object ${o}`)}if(!v(e.from))throw new Error(`string-range-expander: [THROW_ID_03] The input's "from" value resolvedOpts.from, is not a number! It's been given as ${typeof e.from}, equal to ${JSON.stringify(e.from,null,0)}`);if(!v(e.to))throw new Error(`string-range-expander: [THROW_ID_04] The input's "to" value resolvedOpts.to, is not a number! It's been given as ${typeof e.to}, equal to ${JSON.stringify(e.to,null,0)}`);if(e!=null&&e.str&&!e.str[e.from]&&e.from!==e.to)throw new Error(`string-range-expander: [THROW_ID_05] The given input string resolvedOpts.str ("${e.str}") must contain the character at index "from" ("${e.from}")`);if(e!=null&&e.str&&!e.str[e.to-1])throw new Error(`string-range-expander: [THROW_ID_06] The given input string, resolvedOpts.str ("${e.str}") must contain the character at index before "to" ("${e.to-1}")`);if(e.from>e.to)throw new Error(`string-range-expander: [THROW_ID_07] The given "from" index, "${e.from}" is greater than "to" index, "${e.to}". That's wrong!`);if(e.extendToOneSide===null||S(e.extendToOneSide)&&e.extendToOneSide!=="left"&&e.extendToOneSide!=="right"||!S(e.extendToOneSide)&&e.extendToOneSide!==void 0&&e.extendToOneSide)throw new Error(`string-range-expander: [THROW_ID_08] The options value "extendToOneSide" is not recognisable! It's set to: "${e.extendToOneSide}" (${typeof e.extendToOneSide}). It has to be either Boolean "false" or one of strings: "left" or "right"`);if(e!=null&&e.ifLeftSideIncludesThisThenCropTightly&&!S(e.ifLeftSideIncludesThisThenCropTightly))throw new Error(`string-range-expander: [THROW_ID_09] The option "ifLeftSideIncludesThisThenCropTightly", is not a string! It's been given as ${typeof e.ifLeftSideIncludesThisThenCropTightly}, equal to ${JSON.stringify(e.ifLeftSideIncludesThisThenCropTightly,null,0)}`);if(e!=null&&e.ifLeftSideIncludesThisCropItToo&&!S(e.ifLeftSideIncludesThisCropItToo))throw new Error(`string-range-expander: [THROW_ID_10] The option "ifLeftSideIncludesThisCropItToo", is not a string! It's been given as ${typeof e.ifLeftSideIncludesThisCropItToo}, equal to ${JSON.stringify(e.ifLeftSideIncludesThisCropItToo,null,0)}`);if(e!=null&&e.ifRightSideIncludesThisThenCropTightly&&!S(e.ifRightSideIncludesThisThenCropTightly))throw new Error(`string-range-expander: [THROW_ID_11] The option "ifRightSideIncludesThisThenCropTightly", is not a string! It's been given as ${typeof e.ifRightSideIncludesThisThenCropTightly}, equal to ${JSON.stringify(e.ifRightSideIncludesThisThenCropTightly,null,0)}`);if(e!=null&&e.ifRightSideIncludesThisCropItToo&&!S(e.ifRightSideIncludesThisCropItToo))throw new Error(`string-range-expander: [THROW_ID_12] The option "ifRightSideIncludesThisCropItToo", is not a string! It's been given as ${typeof e.ifRightSideIncludesThisCropItToo}, equal to ${JSON.stringify(e.ifRightSideIncludesThisCropItToo,null,0)}`);let t=w(w({},ze),e),a=t.str,i=t.from,u=t.to;if(t.extendToOneSide!=="right"&&(l(a[i-1])&&(l(a[i-2])||t.ifLeftSideIncludesThisCropItToo.includes(a[i-2]))||a[i-1]&&t.ifLeftSideIncludesThisCropItToo.includes(a[i-1])||t.wipeAllWhitespaceOnLeft&&l(a[i-1]))){for(let o=i;o--;)if(!t.ifLeftSideIncludesThisCropItToo.includes(a[o])){if(a[o].trim()){t.wipeAllWhitespaceOnLeft||t.ifLeftSideIncludesThisCropItToo.includes(a[o+1])?i=o+1:i=o+2;break}else if(o===0){t.wipeAllWhitespaceOnLeft?i=0:i=1;break}}}if(t.extendToOneSide!=="left"&&(l(a[u])&&(t.wipeAllWhitespaceOnRight||l(a[u+1]))||t.ifRightSideIncludesThisCropItToo.includes(a[u]))){for(let o=u,m=a.length;o<m;o++)if(!t.ifRightSideIncludesThisCropItToo.includes(a[o])){if(a[o].trim()){t.wipeAllWhitespaceOnRight||t.ifRightSideIncludesThisCropItToo.includes(a[o-1])?u=o:u=o-1;break}else if(o===a.length-1){t.wipeAllWhitespaceOnRight?u=a.length:u=a.length-1;break}}}return(t.extendToOneSide!=="right"&&S(t.ifLeftSideIncludesThisThenCropTightly)&&t.ifLeftSideIncludesThisThenCropTightly&&(a[i-2]&&t.ifLeftSideIncludesThisThenCropTightly.includes(a[i-2])||a[i-1]&&t.ifLeftSideIncludesThisThenCropTightly.includes(a[i-1]))||t.extendToOneSide!=="left"&&S(t.ifRightSideIncludesThisThenCropTightly)&&t.ifRightSideIncludesThisThenCropTightly&&(a[u+1]&&t.ifRightSideIncludesThisThenCropTightly.includes(a[u+1])||a[u]&&t.ifRightSideIncludesThisThenCropTightly.includes(a[u])))&&(t.extendToOneSide!=="right"&&l(a[i-1])&&!t.wipeAllWhitespaceOnLeft&&(i-=1),t.extendToOneSide!=="left"&&l(a[u])&&!t.wipeAllWhitespaceOnRight&&(u+=1)),t.addSingleSpaceToPreventAccidentalConcatenation&&((s=a[i-1])!=null&&s.trim())&&((g=a[u])!=null&&g.trim())&&(!t.ifLeftSideIncludesThisThenCropTightly&&!t.ifRightSideIncludesThisThenCropTightly||!((!t.ifLeftSideIncludesThisThenCropTightly||t.ifLeftSideIncludesThisThenCropTightly.includes(a[i-1]))&&(!t.ifRightSideIncludesThisThenCropTightly||a[u]&&t.ifRightSideIncludesThisThenCropTightly.includes(a[u]))))&&(r.test(a[i-1])||r.test(a[u]))?[i,u," "]:[i,u]}var De=fe(ne(),1);var Rt=(0,De.default)();var B="\xA0";function Qe({str:e,idx:r=0,stopAtNewlines:l=!1,stopAtRawNbsp:t=!1}){if(typeof e!="string"||!e.length||((!r||typeof r!="number")&&(r=0),!e[r+1]))return null;if(e[r+1]&&(e[r+1].trim()||l&&`
\r`.includes(e[r+1])||t&&e[r+1]===B))return r+1;if(e[r+2]&&(e[r+2].trim()||l&&`
\r`.includes(e[r+2])||t&&e[r+2]===B))return r+2;for(let a=r+1,i=e.length;a<i;a++)if(e[a].trim()||l&&`
\r`.includes(e[a])||t&&e[a]===B)return a;return null}function L(e,r=0){return Qe({str:e,idx:r,stopAtNewlines:!1,stopAtRawNbsp:!1})}function Xe({str:e,idx:r,stopAtNewlines:l,stopAtRawNbsp:t}){if(typeof e!="string"||!e.length||((!r||typeof r!="number")&&(r=0),r<1))return null;if(e[~-r]&&(e[~-r].trim()||l&&`
\r`.includes(e[~-r])||t&&e[~-r]===B))return~-r;if(e[r-2]&&(e[r-2].trim()||l&&`
\r`.includes(e[r-2])||t&&e[r-2]===B))return r-2;for(let a=r;a--;)if(e[a]&&(e[a].trim()||l&&`
\r`.includes(e[a])||t&&e[a]===B))return a;return null}function z(e,r=0){return Xe({str:e,idx:r,stopAtNewlines:!1,stopAtRawNbsp:!1})}var Ae="6.0.22";var et=Ae,E=new Se({limitToBeAddedWhitespace:!0}),Ie={lineLengthLimit:500,removeIndentations:!0,removeLineBreaks:!1,removeHTMLComments:!1,removeCSSComments:!0,reportProgressFunc:null,reportProgressFuncFrom:0,reportProgressFuncTo:100,breakToTheLeftOf:["</td","<html","</html","<head","</head","<meta","<link","<table","<script","<\/script","<!DOCTYPE","<style","</style","<title","<body","@media","</body","<!--[if","<!--<![endif","<![endif]"],mindTheInlineTags:["a","abbr","acronym","audio","b","bdi","bdo","big","br","button","canvas","cite","code","data","datalist","del","dfn","em","embed","i","iframe","img","input","ins","kbd","label","map","mark","meter","noscript","object","output","picture","progress","q","ruby","s","samp","script","select","slot","small","span","strong","sub","sup","svg","template","textarea","time","u","tt","var","video","wbr"]};function tt(e,r){var ue,ae;let l=Date.now();if(!S(e))throw e===void 0?new Error("html-crush: [THROW_ID_01] the first input argument is completely missing! It should be given as string."):new Error(`html-crush: [THROW_ID_02] the first input argument must be string! It was given as "${typeof e}", equal to:
${JSON.stringify(e,null,4)}`);if(r&&!M(r))throw new Error(`html-crush: [THROW_ID_03] the second input argument, options object, should be a plain object but it was given as type ${typeof r}, equal to ${JSON.stringify(r,null,4)}`);if(r&&Array.isArray(r.breakToTheLeftOf)&&r.breakToTheLeftOf.length){for(let n=0,U=r.breakToTheLeftOf.length;n<U;n++)if(!S(r.breakToTheLeftOf[n]))throw new TypeError(`html-crush: [THROW_ID_05] the resolvedOpts.breakToTheLeftOf array contains non-string elements! For example, element at index ${n} is of a type "${typeof r.breakToTheLeftOf[n]}" and is equal to:
${JSON.stringify(r.breakToTheLeftOf[n],null,4)}`)}let t=w(w({},Ie),r);typeof t.removeHTMLComments=="boolean"&&(t.removeHTMLComments=t.removeHTMLComments?1:0);let a="";Array.isArray(t.breakToTheLeftOf)&&t.breakToTheLeftOf.length&&(a=[...new Set(t.breakToTheLeftOf.map(n=>n[0]))].join(""));let i={removeHTMLComments:!1,removeCSSComments:!1},u=null,s=null,g=!1,o=0,m=0,c=!1,y=!1,$=null,h=null,O=null,C=null,T,p=null,b=null,d=null,D=null,N=null,R=null,V=">};",j="<",Ce="!",Ne=">",ve="<",oe="{},:;<>~+",Q=oe,X=oe,_=!0,I=e.length,Re=Math.floor(I/2),se=.01,le;t.reportProgressFunc&&(le=Math.floor(t.reportProgressFuncTo-(t.reportProgressFuncTo-t.reportProgressFuncFrom)*se-t.reportProgressFuncFrom));let H,q=0,A=`
`;if(e.includes(`\r
`)?A=`\r
`:e.includes("\r")&&(A="\r"),I){for(let n=0;n<I;n++){if(t.reportProgressFunc&&(I>1e3&&I<2e3?n===Re&&t.reportProgressFunc(Math.floor((t.reportProgressFuncTo-t.reportProgressFuncFrom)/2)):I>=2e3&&(H=t.reportProgressFuncFrom+Math.floor(n/I*(le||1)),H!==q&&(q=H,t.reportProgressFunc(H)))),m++,!T&&c&&e[n]==="}"&&e[n-1]==="}"&&(o+1>=t.lineLengthLimit?(E.push(n,n,A),o=0):(p=n,b=n,d=" ")),T&&typeof T=="number"&&n>=T&&(T=void 0),C!==null&&e.startsWith("<\/script",n)&&!F(e[n+8])){if((t.removeIndentations||t.removeLineBreaks)&&n>0&&e[~-n]&&!e[~-n].trim()){for(let f=n;f--;)if(e[f]===`
`||e[f]==="\r"||e[f].trim()){f+1<n&&E.push(f+1,n);break}}C=null,T=!1,n+=8;continue}if(!T&&!c&&e.startsWith("<script",n)&&!F(e[n+7])){C=n,T=!0;let f="";(t.removeLineBreaks||t.removeIndentations)&&s!==null&&(s>0&&(f=A),E.push(s,n,f)),s=null,u=null}if(N!==null&&D===null&&!/\w/.test(e[n])){D=e.slice(N,n);let f=L(e,~-n);typeof f=="number"&&e[f]===">"&&!e[n].trim()&&L(e,n)?E.push(n,L(e,n)):f&&e[f]==="/"&&e[L(e,f)]===">"&&(!e[n].trim()&&L(e,n)&&E.push(n,L(e,n)),e[f+1]!==">"&&L(e,f+1)&&E.push(f+1,L(e,f+1)))}if(!T&&!c&&!$&&e[~-n]==="<"&&N===null&&(/\w/.test(e[n])?N=n:e[L(e,~-n)]==="/"&&/\w/.test(e[L(e,L(e,~-n))]||"")&&(N=L(e,L(e,~-n)))),!T&&(c||$)&&h!==null&&e[n]==="*"&&e[n+1]==="/"&&([p,b]=K({str:e,from:h,to:n+2,ifLeftSideIncludesThisThenCropTightly:Q||"",ifRightSideIncludesThisThenCropTightly:X||""}),h=null,p!=null?E.push(p,b):(o+=1,n+=1),T=n+2),!T&&(c||$)&&h===null&&e[n]==="/"&&e[n+1]==="*"&&(i.removeCSSComments||(i.removeCSSComments=!0),t.removeCSSComments&&(h=n)),y&&e.startsWith("![endif",n+1)&&(y=!1),!T&&!c&&!$&&O!==null){let f;e.startsWith("-->",n)?f=3:e[n]===">"&&e[n-1]==="]"&&(f=1),f&&([p,b]=K({str:e,from:O,to:n+f}),O=null,p!=null?t.lineLengthLimit&&m-(b-p)>=t.lineLengthLimit?(E.push(p,b,A),m=-f):(E.push(p,b),m-=b-p):(o+=f-1,n+=f-1),T=n+f)}if(!T&&!c&&!$&&(e.startsWith("<!--",n)||t.removeHTMLComments===2&&e.startsWith("<![endif",n))&&O===null&&(e.startsWith("[if",n+4)?(y||(y=!0),t.removeHTMLComments===2&&(O=n)):t.removeHTMLComments&&(!y||t.removeHTMLComments===2)&&(O=n),i.removeHTMLComments||(i.removeHTMLComments=!0)),!T&&c&&h===null&&e.startsWith("</style",n)&&!F(e[n+7])?c=!1:!T&&!c&&h===null&&e.startsWith("<style",n)&&!F(e[n+6])&&(c=!0,(t.removeLineBreaks||t.removeIndentations)&&t.breakToTheLeftOf.includes("<style")&&e.startsWith(' type="text/css">',n+6)&&e[n+24]&&E.push(n+23,n+23,A)),!T&&!$&&`"'`.includes(e[n])&&e.endsWith("style=",n)&&($=n),!T&&!e[n].trim())s===null&&(s=n);else if(!T&&!((c||$)&&h!==null)){if(s!==null){if(t.removeLineBreaks&&(o+=1),_)_=!1,(t.removeIndentations||t.removeLineBreaks)&&E.push(0,n);else if(t.removeIndentations&&!t.removeLineBreaks&&(!g&&u!==null&&n>u?E.push(u+1,n):s+1<n&&(e.endsWith("]>",s)||e.endsWith("-->",s)||e.startsWith("<![",n)||e.startsWith("<!--<![",n)?E.push(s,n):e[s]===" "?E.push(s+1,n):e[~-n]===" "?E.push(s,~-n):E.push(s,n," "))),t.removeLineBreaks||$){if(a.includes(e[n])&&ie(e,n,t.breakToTheLeftOf)){!(`\r
`.includes(e[~-n])&&s===~-n)&&!(e[~-n]===`
`&&e[n-2]==="\r"&&s===n-2)&&E.push(s,n,A),p=null,b=null,d=null,s=null,o=1;continue}let f=" ";e[n]==="<"&&J(e,n,t.mindTheInlineTags,{cb:x=>!x||!/\w/.test(x)})||(e[~-s]&&Ne.includes(e[~-s])&&ve.includes(e[n])||(c||$)&&h===null&&(Q.includes(e[~-s])||X.includes(e[n]))||e.startsWith("!important",n)&&!y||$&&(e[~-s]==="'"||e[~-s]==='"')||e[~-s]==="}"&&e.startsWith("</style",n)||e[n]===">"&&(`'"`.includes(e[z(e,n)])||e[L(e,n)]==="<")||e[n]==="/"&&e[L(e,n)]===">")&&(f="",e[n]==="/"&&e[n+1]===">"&&L(e,n)&&L(e,n)>n+1&&(E.push(n+1,L(e,n)),o-=L(e,n)-n+1)),c&&e[n]==="}"&&s&&e[s-1]==="}"&&(f=" "),f!=null&&f.length&&(o+=1),t.lineLengthLimit?o>=t.lineLengthLimit||!e[n+1]||e[n]===">"||e[n]==="/"&&e[n+1]===">"?((o>t.lineLengthLimit||o===t.lineLengthLimit&&((ue=e[n+1])!=null&&ue.trim())&&!V.includes(e[n])&&!j.includes(e[n+1]))&&(f=A,o=1),(o>t.lineLengthLimit||!(f===" "&&n===s+1))&&(E.push(s,n,f),u=null),p=null,b=null,d=null):(p===null||s<p)&&(p=s,b=n,d=f):n===s+1&&f===" "||E.push(s,n,f)}s=null,g||(g=!0)}else _&&(_=!1),t.removeLineBreaks&&(o+=1);g||(g=!0)}if(!T&&!_&&n!==0&&t.removeLineBreaks&&(t.lineLengthLimit||a)&&!e.startsWith("</a",n)){if(a&&ie(e,n,t.breakToTheLeftOf)&&e.slice(0,n).trim()&&(!e.startsWith("<![endif]",n)||!Le(e,n,"<!--"))){E.push(n,n,A),p=null,b=null,d=null,o=1;continue}else if(t.lineLengthLimit&&o<=t.lineLengthLimit){if(!e[n+1]||j.includes(e[n])&&!Ce.includes(e[n])||V.includes(e[n])||!e[n].trim()){if(p!==null&&b!==null&&(p!==b||d!=null&&d.length)){let f=d;e[n].trim()&&((ae=e[n+1])!=null&&ae.trim())&&o+(d?d.length:0)>t.lineLengthLimit&&(f=A),(o+(f?f.length:0)>t.lineLengthLimit||!(f===" "&&b===p+1&&e[p]===" "))&&(e[~-p]==="}"&&e[b]==="{"||(E.push(p,b,f),u=null))}e[n].trim()&&(j.includes(e[n])||e[~-n]&&V.includes(e[~-n]))&&S(R)&&(!D||!t.mindTheInlineTags.includes(D))&&!(e[n]==="<"&&J(e,n,t.mindTheInlineTags,{cb:f=>!f||!/\w/.test(f)}))&&!(e[n]==="<"&&J(e,n,t.mindTheInlineTags,{trimCharsBeforeMatching:"/",cb:f=>!f||!/\w/.test(f)}))?(p=n,b=n,d=null):h===null&&p!==null&&($||!t.mindTheInlineTags||!Array.isArray(t.mindTheInlineTags)||Array.isArray(t.mindTheInlineTags.length)&&!t.mindTheInlineTags.length||!S(D)||Array.isArray(t.mindTheInlineTags)&&t.mindTheInlineTags.length&&S(D)&&!t.mindTheInlineTags.includes(D))&&!(e[n]==="<"&&J(e,n,t.mindTheInlineTags,{trimCharsBeforeMatching:"/",cb:f=>!f||!/\w/.test(f)}))&&(p=null,b=null,d=null)}}else if(t.lineLengthLimit)if(j.includes(e[n])&&!(e[n]==="<"&&J(e,n,t.mindTheInlineTags,{trimCharsBeforeMatching:"/",cb:f=>!f||!/\w/.test(f)})))if(p!==null&&b!==null&&(p!==b||d!=null&&d.length)){let f=d!=null&&d.length?d.length:0;o-(b-p-f)-1>t.lineLengthLimit||(E.push(p,b,d),o-(b-p-f)-1===t.lineLengthLimit&&(E.push(n,n,A),o=0),p=null,b=null,d=null)}else E.push(n,n,A),o=0;else e[n+1]&&V.includes(e[n])&&S(D)&&Array.isArray(t.mindTheInlineTags)&&t.mindTheInlineTags.length&&!t.mindTheInlineTags.includes(D)?p!==null&&b!==null&&(p!==b||d!=null&&d.length)||(E.push(n+1,n+1,A),o=0):e[n].trim()&&(e[n+1]||p!==null&&b!==null&&(p!==b||d!=null&&d.length)&&E.push(p,b,A))}if(!T&&!_&&t.removeLineBreaks&&t.lineLengthLimit&&o>=t.lineLengthLimit&&p!==null&&b!==null&&!V.includes(e[n])&&!j.includes(e[n])&&!"/".includes(e[n])&&!(o===t.lineLengthLimit&&e[n+1]&&!e[n+1].trim())){let f=A;e[n+1]&&!e[n+1].trim()&&o===t.lineLengthLimit&&(f=d),f===A&&!e[~-p].trim()&&z(e,p)&&(p=z(e,p)+1),E.push(p,b,f),o=n-b,e[n].length&&(o+=1),p=null,b=null,d=null}if((!T&&e[n]===`
`||e[n]==="\r"&&(!e[n+1]||e[n+1]&&e[n+1]!==`
`))&&(u=n,g&&(g=!1),!t.removeLineBreaks&&s!==null&&s<n&&e[n+1]&&e[n+1]!=="\r"&&e[n+1]!==`
`&&E.push(s,n)),e[n+1]||(c&&h!==null?E.push([...K({str:e,from:h,to:n,ifLeftSideIncludesThisThenCropTightly:Q||"",ifRightSideIncludesThisThenCropTightly:X||""})]):s&&e[n]!==`
`&&e[n]!=="\r"?E.push(s,n+1):s&&(e[n]==="\r"&&e[n+1]===`
`||e[n]===`
`&&e[n-1]!=="\r")&&E.push(s,n)),!T&&$&&$<n&&e[$]===e[n]&&($=null),!T&&!c&&e.startsWith("<pre",n)&&!F(e[n+4])){let f=e.indexOf("</pre",n+5);f>0&&(T=f)}if(!T&&!c&&e.startsWith("<code",n)&&!F(e[n+5])){let f=e.indexOf("</code",n+5);f>0&&(T=f)}if(!T&&e.startsWith("<![CDATA[",n)){let f=e.indexOf("]]>",n+9);f>0&&(T=f)}!T&&!c&&!$&&N!==null&&e[n]===">"&&(e[L(e,n)]==="<"&&(R=D),N=null,D=null),e[n]==="<"&&R!==null&&(R=null),c&&e[n]==="{"&&e[n+1]==="{"&&e.indexOf("}}")!==-1&&(T=e.indexOf("}}")+2);let U=!0}if(E.current()){let n=E.current();E.wipe();let U=t.reportProgressFuncTo-(t.reportProgressFuncTo-t.reportProgressFuncFrom)*se,f=de(e,n,Ve=>{t.reportProgressFunc&&I>=2e3&&(H=Math.floor(U+(t.reportProgressFuncTo-U)*(Ve/100)),H!==q&&(q=H,t.reportProgressFunc(H)))}),x=f.length;return{log:{timeTakenInMilliseconds:Date.now()-l,originalLength:I,cleanedLength:x,bytesSaved:Math.max(I-x,0),percentageReducedOfOriginal:I?Math.round(Math.max(I-x,0)*100/I):0},ranges:n,applicableOpts:i,result:f}}}return{log:{timeTakenInMilliseconds:Date.now()-l,originalLength:I,cleanedLength:I,bytesSaved:0,percentageReducedOfOriginal:0},applicableOpts:i,ranges:null,result:e}}return We(nt);})();
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 6.0.13
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
/**
 * @name ranges-merge
 * @fileoverview Merge and sort string index ranges
 * @version 9.0.18
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-merge/}
 */
/**
 * @name ranges-apply
 * @fileoverview Take an array of string index ranges, delete/replace the string according to them
 * @version 7.0.19
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-apply/}
 */
/**
 * @name string-collapse-leading-whitespace
 * @fileoverview Collapse the leading and trailing whitespace of a string
 * @version 7.0.9
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-collapse-leading-whitespace/}
 */
/**
 * @name codsen-utils
 * @fileoverview Various utility functions
 * @version 1.6.7
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/codsen-utils/}
 */
/**
 * @name ranges-push
 * @fileoverview Gather string index ranges
 * @version 7.0.18
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-push/}
 */
/**
 * @name arrayiffy-if-string
 * @fileoverview Put non-empty strings into arrays, turn empty-ones into empty arrays. Bypass everything else.
 * @version 5.0.10
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/arrayiffy-if-string/}
 */
/**
 * @name string-match-left-right
 * @fileoverview Match substrings on the left or right of a given index, ignoring whitespace
 * @version 9.0.22
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-match-left-right/}
 */
/**
 * @name string-range-expander
 * @fileoverview Expands string index ranges within whitespace boundaries until letters are met
 * @version 4.0.17
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-range-expander/}
 */
/**
 * @name string-left-right
 * @fileoverview Looks up the first non-whitespace character to the left/right of a given index
 * @version 6.0.20
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-left-right/}
 */
